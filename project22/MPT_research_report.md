# *Project22: research report on MPT<br>
<br>

## 一、MPT概述<br>
MPT(Merkel-Patricia Tree，梅克尔-帕特里夏树)，MPT提供了一个基于密码学验证的底层数据结构，是Ethereum用来存储区块数据的核心数据结构，用来存储键值对(key-value)关系。MPT是完全确定性的，这是指在一颗MPT上的一组键值对是唯一确定的，相同内容的键可以保证找到同样的值，并且有同样的根哈希(root hash)。MPT的插入、查找、删除操作的事件复杂度都是O(log(n))，相对于其它基于复杂比较的树结构(比如红黑树)，MPT更容易理解，也更易于编码实现。<br><br>


## 二、MPT的基础<br>
### 1、 字典树 Trie<br>
字典树（Trie）也称前缀树（prefix tree），是一种有序的树结构。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br>
<br>
键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。<br>
<br>
实际上trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串，并且有几个这样的字符串。常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/3ae65e70-2bf1-46b0-bd57-a29b5a81628d)

<br>
字典树用于存储动态的集合或映射，其中的键通常是字符串，很多数据库的底层都采用的是树结构，以太坊最初的想法也是这样，但字典树还远远不够，主要问题是访问效率很低。<br>
<br>

### 2、 Patricia树<br>
 Patricia树，或称Patricia trie，或crit bit tree，压缩前缀树，是一种更节省空间的Trie。如果一个基数树的“基数”（radix）为2或2的整数次幂，就被称为“帕特里夏树”，有时也直接认为帕特里夏树就是基数树。<br>
<br>
以太坊中采用Hex字符作为key的字符集，也就是基数为16的基数树，每个节点最多可以有16个子节点，再加上value，所以共有17个“插槽”（slot）位置。<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/26c16307-b172-4658-8c30-bdeedef489ac)

<br>
帕特里夏树优化了访问效率，但还有一个问题没有解决。基数树节点之间的连接方式是指针，一般是用32位或64位的内存地址作为指针的值，比如C语言就是这么做的。但这种直接存地址的方式无法提供对数据内容的校验，而这在区块链这样的分布式系统中非常重要。<br>
<br>

### 3、Merkle树<br>
Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。<br>
<br>
梅克尔树就是最经典的解决数据校验的一种方式，用每个节点的hash值来建立对应的关系，底层的叶子节点都算一个hash，这是一个二叉树，两两hash之间再算一次hash，不断往上计算得出top hash算作一个根节点存到区块里面，去校验的时候，如果叶子节点发生改动，按照规则两两一hash计算得出的根节点会不一样，就知道数据发生了变动。<br>

![image](https://github.com/lemonade310/homework-group25/assets/139195261/63eee6f6-a70c-421b-aa9b-69462fc09a8d)


<br>
梅克尔树可以实现数据校验，防止篡改。以太坊要去做hash的是整个要存储内容的RLP编码，所以以太坊相当于把自己的value先做RLP编码，然后再去求hash，然后把最后得到的hash值作为在数据库中存储的位置，所以在MPT中的节点里面用hash作为key，访问的的时候根据hash在数据库中找到对应的值。<br>
<br>

### 4、 MPT（Merkle Patricia Tree）树<br>
MPT（Merkle Patricia Tree）就是Merkle Tree和Patricia Tree这两者混合后的产物。<br>
<br>
相对于普通的前缀树，MPT树能有效减少Trie树的深度，增加Trie树的平衡性。而且通过节点的hash值进行树的节点的链接，有助于提高树的安全性和可验证性。<br>
<br>

## 三、MPT的基本结构<br>
### 1、 节点分类<br>
MPT树中的节点包括空节点、叶子节点、扩展节点和分支节点：<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/6af9df05-f6fd-4005-b9e0-433aa2e4ccc5)

<br>
·空节点（NULL）：简单的表示空，在代码中是一个空串。<br>
·叶子节点（leaf）：表示为[key,value]的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。<br>
·扩展节点（extension）：也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。<br>
·分支节点（branch）：因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。<br>

![image](https://github.com/lemonade310/homework-group25/assets/139195261/39c68581-2c34-468b-bb35-c46a8b6b9a24)

<br>
如图所示:<br>
MPT节点有不同的类型，先从上面开始看，最上面是根节点，是一个扩展结点，首先存一个压缩路径，然后存一个指向下一个节点的hash，把压缩路径的前缀单独领出来了，实际上是存储的时候是合在一起存的，他的前缀给的是0，因为后面的压缩起来的路径是偶数，偶数还是扩展结点，前缀的二进制表示就是0000，还要补0000，但是这里显示的只是前缀，没有显示补0的操作。<br>
<br>
然后后面存一个hash指向下一个节点。下一个节点是一个分支节点，因为我们发现这个地方没法去压缩路径，因为他有不同的路径出现，所以就岔开了。分支节点里面1这个插槽对应的是一个叶子节点，前缀是2，因为他后面压缩的路径是偶数并且是叶子节点， 后面还有value，所以我们这里存的从根节点到分支节点，再到叶子节点。表示了一个什么键值对存储呢，他的key就是这个路径，从前面压缩出来的路径a7，然后往下走到1，然后1355，他的值是45eth，所以要存储的键是:a711355，值是45这样一个键值对，在MPT中就是这样组织存储。<br>
<br>
总共有2个扩展节点，2个分支节点，4个叶子节点。<br>
其中叶子结点的键值情况为：<br> 

![image](https://github.com/lemonade310/homework-group25/assets/139195261/699ca7e3-0348-4fac-8b09-c4c879bde3d3)

<br>
节点的前缀：<br>

![image](https://github.com/lemonade310/homework-group25/assets/139195261/4e59ad09-d1b3-4de8-8347-d7acafb7cd55)

<br>  

### 2、 key值编码<br>
在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，三种编码方式分别为：<br>
·Raw编码（原生的字符）<br>
·Hex编码（扩展的16进制编码）<br>
·Hex-Prefix编码（16进制前缀编码）<br>
<br>
在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，三种编码方式分别为：<br>
·Raw编码（原生的字符）<br>
·Hex编码（扩展的16进制编码）<br>
·Hex-Prefix编码（16进制前缀编码）<br>
<br>
####  ①Raw编码<br>
Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。<br>
<br>
例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是['c', 'a', 't']，换成ASCII表示方式就是[63, 61, 74]<br>
<br>
####   ②Hex编码<br>
为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。<br>
<br>
从Raw编码向Hex编码的转换规则是：<br>
将Raw编码的每个字符，根据高4位低4位拆成两个字节；<br>
若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；<br>
若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；<br>
key为“cat”, value为“dog”的数据项，其Hex编码为[3, 15, 3, 13, 4, 10, 16]<br>
<br>
<br>
Hex编码用于对内存中MPT树节点key进行编码<br>
<br>
####   ③HP编码<br>
叶子／扩展节点这两种节点定义是共享的，即便持久化到数据库中，存储的方式也是一致的。那么当节点加载到内存是，同样需要通过一种额外的机制来区分节点的类型。于是以太坊就提出了一种HP编码对存储在数据库中的叶子／扩展节点的key进行编码区分。在将这两类节点持久化到数据库之前，首先会对该节点的key做编码方式的转换，即从Hex编码转换成HP编码。<br>
<br>
HP编码的规则如下：<br>
若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；<br>
在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；<br>
若原本key的长度为奇数，则在key之前再增加一个值为0x0的半字节；<br>
将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；<br>
若Hex编码为[3, 15, 3, 13, 4, 10, 16]，则HP编码的值为[32, 63, 61, 74]<br>
<br>
HP编码用于对数据库中的树节点key进行编码<br>
<br>
####   ④转换关系<br>
以上三种编码方式的转换关系为：<br>
Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；<br>
Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；<br>
HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；<br>
<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/c57fe5fe-780e-44a1-ad4d-f435cbf8b28a)

<br>
<br>

###  3、 安全的MPT<br>
以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：<br>
查询一个节点可能会需要许多次IO读取，效率低下；<br>
系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；<br>
所有的key其实是一种明文的形式进行存储；<br>
<br><br>
为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(sha3(key), value)。<br>
<br>
这样传入MPT接口的key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；但是每次树操作需要增加一次哈希计算，并且需要在数据库中存储额外的sha3(key)与key之间的对应关系。<br>
<br>

## 四、MPT的功能——以太坊的轻节点扩展<br>
MPT能够提供的一个重要功能——默克尔证明，使用默克尔证明能够实现轻节点的扩展。<br>
<br>
### 1、轻节点<br>
在以太坊或比特币中，一个参与共识的全节点通常会维护整个区块链的数据，每个区块中的区块头信息，所有的交易，回执信息等。由于区块链的不可篡改性，这将导致随着时间的增加，整个区块链的数据体量会非常庞大。运行在个人PC或者移动终端的可能性显得微乎其微。为了解决这个问题，一种轻量级的，只存储区块头部信息的节点被提出。这种节点只需要维护链中所有的区块头信息（一个区块头的大小通常为几十个字节，普通的移动终端设备完全能够承受出）。<br>
<br>
在公链的环境下，仅仅通过本地所维护的区块头信息，轻节点就能够证明某一笔交易是否存在与区块链中；某一个账户是否存在与区块链中，其余额是多少等功能。<br>
<br>
### 2、默克尔证明<br>
默克尔证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。<br>
<br>
### 3、默克尔证明过程<br>
如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在与默克尔树中，只需要向全节点发送该请求，全节点会返回一个1FXq:18,ec20,8f74的一个路径（默克尔路径，如图2黄色框所表示的）。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/48faa191-2ea2-4d16-8ac8-bdd5ef14f990)

<br>

### 4、默克尔证明安全性<br>
（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。<br>
由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。<br>
<br>
（2）为什么不直接向全节点请求该节点是否存在于区块链中？<br>
由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的默克尔路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。<br>
<br>
### 5、简单支付验证<br>
在以太坊中，利用默克尔证明在轻节点中实现简单支付验证，即在无需维护具体交易信息的前提下，证明某一笔交易是否存在于区块链中。<br>
<br>

## 五、MPT在以太坊中的应用<br>
1、存储账户和合约状态：以太坊使用MPT来存储账户和合约的状态。每个账户都有一个唯一的地址，而该地址对应的状态数据存储在MPT中。通过MPT的哈希树结构，可以快速检索和验证特定账户的状态。<br>
2、交易验证：以太坊的交易数据也使用MPT进行存储和验证。每个区块中的交易数据通过MPT的哈希树结构组织起来，其中每个叶节点存储着交易数据的哈希值。通过验证根节点的哈希值，可以确保交易数据的完整性和正确性。<br>
3、存储合约代码：在以太坊中，智能合约的代码也是存储在MPT中的。合约代码被存储在特殊的账户中，通过账户地址和MPT的索引，可以快速检索和获取合约代码。<br>
4、事件日志存储：以太坊中的智能合约可以通过事件日志记录重要的状态变化或交互信息。事件日志通过MPT进行存储，每个区块中的事件日志都被组织成一个MPT结构，便于查询和检索。<br>
<br>
<br>
综上所述，MPT在以太坊中不仅提供了高效的数据存储和检索能力，还确保了数据的完整性和可验证性。它在以太坊的区块链技术中扮演着重要的角色，支持以太坊的各种功能和特性的实现。<br>
