# *Project22: research report on MPT<br>
<br>

### 一、MPT概述<br><br>
MPT(Merkel-Patricia Tree，梅克尔-帕特里夏树)，MPT提供了一个基于密码学验证的底层数据结构，是Ethereum用来存储区块数据的核心数据结构，用来存储键值对(key-value)关系。MPT是完全确定性的，这是指在一颗MPT上的一组键值对是唯一确定的，相同内容的键可以保证找到同样的值，并且有同样的根哈希(root hash)。MPT的插入、查找、删除操作的事件复杂度都是O(log(n))，相对于其它基于复杂比较的树结构(比如红黑树)，MPT更容易理解，也更易于编码实现。<br><br>


### 二、MPT的基础<br><br>
#### 1、 字典树 Trie<br>
字典树（Trie）也称前缀树（prefix tree），是一种有序的树结构。其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br>
<br>
键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。<br>
<br>
实际上trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串，并且有几个这样的字符串。常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/3ae65e70-2bf1-46b0-bd57-a29b5a81628d)

<br>
字典树用于存储动态的集合或映射，其中的键通常是字符串，很多数据库的底层都采用的是树结构，以太坊最初的想法也是这样，但字典树还远远不够，主要问题是访问效率很低。<br>
<br>

#### 2、 Patricia树<br>
 Patricia树，或称Patricia trie，或crit bit tree，压缩前缀树，是一种更节省空间的Trie。如果一个基数树的“基数”（radix）为2或2的整数次幂，就被称为“帕特里夏树”，有时也直接认为帕特里夏树就是基数树。<br>
<br>
以太坊中采用Hex字符作为key的字符集，也就是基数为16的基数树，每个节点最多可以有16个子节点，再加上value，所以共有17个“插槽”（slot）位置。<br>
![image](https://github.com/lemonade310/homework-group25/assets/139195261/26c16307-b172-4658-8c30-bdeedef489ac)

<br>
帕特里夏树优化了访问效率，但还有一个问题没有解决。基数树节点之间的连接方式是指针，一般是用32位或64位的内存地址作为指针的值，比如C语言就是这么做的。但这种直接存地址的方式无法提供对数据内容的校验，而这在区块链这样的分布式系统中非常重要。<br>
<br>
<br>
·空节点（NULL）：简单的表示空，在代码中是一个空串。<br>
·叶子节点（leaf）：表示为[key,value]的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。<br>
·扩展节点（extension）：也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。<br>
·分支节点（branch）：因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。<br>

![image](https://github.com/lemonade310/homework-group25/assets/139195261/39c68581-2c34-468b-bb35-c46a8b6b9a24)

<br>
如图所示:<br>
MPT节点有不同的类型，先从上面开始看，最上面是根节点，是一个扩展结点，首先存一个压缩路径，然后存一个指向下一个节点的hash，把压缩路径的前缀单独领出来了，实际上是存储的时候是合在一起存的，他的前缀给的是0，因为后面的压缩起来的路径是偶数，偶数还是扩展结点，前缀的二进制表示就是0000，还要补0000，但是这里显示的只是前缀，没有显示补0的操作。<br>
<br>
然后后面存一个hash指向下一个节点。下一个节点是一个分支节点，因为我们发现这个地方没法去压缩路径，因为他有不同的路径出现，所以就岔开了。分支节点里面1这个插槽对应的是一个叶子节点，前缀是2，因为他后面压缩的路径是偶数并且是叶子节点， 后面还有value，所以我们这里存的从根节点到分支节点，再到叶子节点。表示了一个什么键值对存储呢，他的key就是这个路径，从前面压缩出来的路径a7，然后往下走到1，然后1355，他的值是45eth，所以要存储的键是:a711355，值是45这样一个键值对，在MPT中就是这样组织存储。<br>
<br>
总共有2个扩展节点，2个分支节点，4个叶子节点。<br>
其中叶子结点的键值情况为：<br> 

![image](https://github.com/lemonade310/homework-group25/assets/139195261/699ca7e3-0348-4fac-8b09-c4c879bde3d3)

<br>
节点的前缀：<br>

![image](https://github.com/lemonade310/homework-group25/assets/139195261/4e59ad09-d1b3-4de8-8347-d7acafb7cd55)

<br>  

#### 2、 key值编码<br>
在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，三种编码方式分别为：<br>
·Raw编码（原生的字符）<br>
·Hex编码（扩展的16进制编码）<br>
·Hex-Prefix编码（16进制前缀编码）<br>
<br>
